clc; clear; format long G
%% načtení přibližných souřadnic
ss = load("pribl_sour_jtsk.txt");
gon2rad = pi/200; 

%% Načtení a zpracování XML souborů s daty
% Cesta ke složce se soubory
folder = 'xml_soubory/';
files = dir(fullfile(folder, '*.xml'));

% Kontrolní proměnná pro uložení všech výstupů
data = struct();

% Proměnné pro zpětné volání jednotlivých dat
variables = [];
stanoviska = [];

for k = 1:length(files)
    filepath = fullfile(folder, files(k).name);
    fprintf('Zpracovávám: %s\n', files(k).name);
    
    try
        % Zavolání funkce
        d = parse_trgsit_xml(filepath);
        
        % Extrakce názvu podle stanoviska
        if isfield(d, 'stanovisko')
            stan = strtrim(d.stanovisko); % např. '1001'
            varname = ['data_' stan];        % např. 'data_1001'

            % Dynamické uložení do workspace proměnné
            data.(varname) = d;

            % uložení názvů proměných pro snadnější indexování
            stanoviska = [stanoviska,string(stan)];
            variables = [variables,string(varname)];

            % uložit jako MAT soubor:
            % save(fullfile('data', [varname '.mat']), 'd');

        else
            warning('Soubor %s neobsahuje stanovisko.', files(k).name);
        end
    catch ME
        warning('Chyba při zpracování souboru %s:\n%s', files(k).name, ME.message);
    end
end
disp('Soubory načteny a zpracovány');


%% Centrace směrů, Redukce úhlů do roviny Křovákova zobrazení a Redukce délek

pocet_stanovisek = length(variables);
id_azimut = '';

stanoviska_IDs = zeros(1, pocet_stanovisek);
data_structs = cell(1, pocet_stanovisek);
for i = 1:pocet_stanovisek
    data_structs{i} = data.(variables(i));
    stanoviska_IDs(i) = str2double(data.(variables(i)).stanovisko(1:4));
end

[S,U,ro1,eps] = jtsk2kar(ss(:,3),ss(:,2));

opravy_smeru = [];
redukce_JTSK = [];
Delky1 = [];
Delky2 = [];
% ast_azimut = {};
% ast_azimut2 = {};
for i = 1:pocet_stanovisek
    pom_1 = data_structs{i};
    st = stanoviska_IDs(i);

    osnova_1 = pom_1.centracni_osnova.cil;
    cil_1 = pom_1.centracni_osnova.ex_cil;
    centr_1 = pom_1.centracni_osnova.centr;

    [ X_k1 , Y_k1] = findPoint(ss, st);

    ids = str2double({osnova_1.id});
    if isfield(pom_1, 'gyro')
        id_azimut = pom_1.gyro.id;
        gyro_mereni = pom_1.gyro.observace;
    end

    ind_st1 = find(st==ss(:,1));
    for j = 1:length(ids)
        idx_n = find(stanoviska_IDs == ids(j), 1);
        if isempty(idx_n), continue; end

        pom_2 = data_structs{idx_n};
        st2 = stanoviska_IDs(idx_n);

        [X_k2,Y_k2] = findPoint(ss, st2);
        delka_ss = hypot(Y_k2 - Y_k1, X_k2 - X_k1);

        osnova_2 = pom_2.centracni_osnova.cil;
        cil_2 = pom_2.centracni_osnova.ex_cil;
        centr_2 = pom_2.centracni_osnova.centr;

        idx1 = strcmp({osnova_1.id}, sprintf('%04d', st2));
        smer_1 = osnova_1(idx1).smer;

        idx2 = strcmp({osnova_2.id}, sprintf('%04d', st));
        smer_2 = osnova_2(idx2).smer;

        oprava = CentracniZmena( ...
            smer_1*gon2rad, cil_1.smer*gon2rad, centr_1.smer*gon2rad, centr_1.delka, cil_1.delka, ...
            smer_2*gon2rad, cil_2.smer*gon2rad, centr_2.smer*gon2rad, centr_2.delka, cil_2.delka, ...
            delka_ss);
            % Měřený úhel při měření centrační osnovy, , úhel na excentrický cíl, úhel na centr, délka na centr, délka na exentrický cíl

        % theta = centrace_smeru(ss,st,st2,...
        %     smer_1*gon2rad, cil_1.smer*gon2rad, centr_1.smer*gon2rad, centr_1.delka, cil_1.delka, ...
        %     smer_2*gon2rad, cil_2.smer*gon2rad, centr_2.smer*gon2rad, centr_2.delka, cil_2.delka);
        oprava = oprava/ gon2rad;

        [a] = check_stanovisko(pom_1);

        opravy_smeru = [opravy_smeru; st, a, st2, oprava];

        % Převod směrů do roviny Křovákova zobrazení
        ind_st2 = find(st2==ss(:,1));
        [Dij,~,~,~,~,~] = smerova_korekce(ss(ind_st1,2:3),ss(ind_st2,2:3),eps(ind_st1),eps(ind_st2), ...
            ro1(ind_st2),ro1(ind_st1),S(ind_st1),S(ind_st2));

        redukce_JTSK =  [redukce_JTSK;st, a,st2,Dij/180*200];

    end

    id_l = strcmp({pom_1.uhel.id_leva}, id_azimut);
    id_p = strcmp({pom_1.uhel.id_prava}, id_azimut);
    if any(id_l) || any(id_p)
        gyro_azimut = size(gyro_mereni,2);

        [X_k2,Y_k2] = findPoint(ss, str2num(id_azimut));
        delka_ss = hypot(Y_k2 - Y_k1, X_k2 - X_k1);

        % idx1 = strcmp({pom_1.uhel.id_leva}, id_azimut);
        % if any(idx1)
        %     smer = 0;
        % else
        %     idx1 = strcmp({pom_1.uhel.id_prava}, id_azimut);
        %     smer = pom_1.uhel(idx1).hodnota;
        % end

        idToCheckStr = num2str(id_azimut); 

        exists = strcmp({pom_1.centracni_osnova.cil.id}, idToCheckStr);

        if  any(exists)
            smer = pom_1.centracni_osnova.cil(exists).hodnota;
        else
            left = strcmp({pom_1.uhel.id_leva}, idToCheckStr);
            right = strcmp({pom_1.uhel.id_prava}, idToCheckStr);

            if ~(any(left) || any(right))
                error('Nebylo měřeno na bod')
            end

            if any(left)
                idx1 = strcmp({pom_1.uhel.id_leva}, id_azimut);
                smer = pom_1.uhel(idx1).hodnota;
                id_prava = pom_1.uhel(idx1).id_prava;
                exists = strcmp({pom_1.centracni_osnova.cil.id}, id_prava);
                smer = pom_1.centracni_osnova.cil(exists).smer - smer;
            else
                idx1 = strcmp({pom_1.uhel.id_prava}, id_azimut);
                smer = pom_1.uhel(idx1).hodnota;
                id_leva = pom_1.uhel(idx1).id_leva;
                exists = strcmp({pom_1.centracni_osnova.cil.id}, id_leva);
                smer = pom_1.centracni_osnova.cil(exists).smer + smer;
            end


        end
        gyro_uhel = {gyro_mereni.azimut_centr};
        gyro_cil = {gyro_mereni.azimut};
        gyro_delka = {gyro_mereni.delka_centr};

        for j = 1:gyro_azimut
            oprava = CentracniZmena( ...
            deg2rad(gyro_cil{j}),deg2rad(gyro_uhel{j}), deg2rad(gyro_uhel{j}), gyro_delka{j}, gyro_delka{j}, ...
            smer * gon2rad, cil_1.smer*gon2rad, centr_1.smer*gon2rad, centr_2.delka, cil_2.delka, ...
            delka_ss);

            theta = centrace_smeru(ss,st,st2,...
            smer_1*gon2rad, cil_1.smer*gon2rad, centr_1.smer*gon2rad, centr_1.delka, cil_1.delka, ...
            smer_2*gon2rad, cil_2.smer*gon2rad, centr_2.smer*gon2rad, centr_2.delka, cil_2.delka);
            
                %měřený úhlel, úhel na excentrický cíl, úhel na centr - délka na excentrický cíl a centr jsou stejné, stejný bod
                %měřený úhel na bod(záleží jestli je vlevo nebo v pravo), úhel na excentrický cíl, úhel na centr, 
            gyro_mereni(j).oprava = oprava/ gon2rad;
        end
        oprava = CentracniZmena( ...
        smer * gon2rad, cil_1.smer*gon2rad, centr_1.smer*gon2rad, centr_2.delka, cil_2.delka, ...
        deg2rad(gyro_cil{j}),deg2rad(gyro_uhel{j}), deg2rad(gyro_uhel{j}), gyro_delka{j}, gyro_delka{j}, ...
        delka_ss);
            %měřený úhel na bod(záleží jestli je vlevo nebo v pravo), úhel na excentrický cíl, úhel na centr
            %měřený úhlel, úhel na excentrický cíl, úhel na centr - délka na excentrický cíl a centr jsou stejné, stejný bod
          
        [a] = check_stanovisko(pom_1);

        opravy_smeru = [opravy_smeru; st, a, str2num(id_azimut), oprava/ gon2rad];


        % Převod směrů do roviny Křovákova zobrazení
        id_az = find(ss(:,1)==str2num(id_azimut));
        [Dij,~,~,~,~,~] = smerova_korekce(ss(ind_st1,2:3),ss(id_az,2:3),eps(ind_st1),eps(id_az), ...
                                          ro1(id_az),ro1(ind_st1),S(ind_st1),S(id_az));

        redukce_JTSK =  [redukce_JTSK;st, a,str2num(id_azimut),Dij/180*200];
    end

    % Výpočet astronomických azimutů
    % astro_azimut = pom_1.azimut;
    % id_astr = {astro_azimut.id};
    % angl_astr = {astro_azimut.uhel};
    % time_astr = {astro_azimut.cas_utc};
    % for j = 1:2:size(astro_azimut,2)
    %     if ~isnan(angl_astr{j})
    %         time = sscanf(time_astr{j}, '%d:%d:%f');
    %         time = ((time(1) + time(2)/60 + time(3) /3600));
    %         time_ = sscanf(time_astr{j+1}, '%d:%d:%f');
    %         time_ = ((time_(1) + time_(2)/60 + time_(3) /3600));
    % 
    %         angle =  angl_astr{j};
    %         angle_ = angl_astr{j+1};
    % 
    % 
    %         [sig_ast_1] = astronomical_azimuth([Y_k1,X_k1],time,angle,S0,Ra,Dec,Ra_,Dec_,sec,q1,n,T2TT,DUT1);
    %         ast_azimut2 = [ast_azimut2;{pom_1.mericka_ceta(1).jmeno,pom_1.mericka_ceta(2).jmeno,pom_1.datum,time_astr{j},id_astr{j},400 - angl_astr{j},sig_ast_1/pi*200}];
    %         [sig_ast] = astronomical_azimuth([Y_k1,X_k1],time_,angle_,S0,Ra,Dec,Ra_,Dec_,sec,q1,n,T2TT,DUT1);
    %         ast_azimut2 = [ast_azimut2;{pom_1.mericka_ceta(1).jmeno,pom_1.mericka_ceta(2).jmeno,pom_1.datum,time_astr{j+1},id_astr{j+1},400 - angl_astr{j+1},sig_ast/pi*200}];
    % 
    %        sig_ast = (sig_ast_1+sig_ast)/2;
    % 
    %         h = floor(time);
    %         m = floor((time - h) * 60);
    %         s = ((time - h) * 60 - m) * 60;
    %         txt = sprintf('%d:%d:%f', h, m, s);
    %         ast_azimut = [ast_azimut;{pom_1.mericka_ceta(1).jmeno,pom_1.mericka_ceta(2).jmeno,pom_1.datum,txt,id_astr{j},angle ,sig_ast/pi*200}];
    %     end
    % end

    % Redukce délek
    [delky,delky2] = Redukce2(pom_1);
    [a] = check_stanovisko(pom_1);
    a1 = a * ones(size(delky,1),1);
    a2 = a * ones(size(delky2,1),1);

    Delky1 = [Delky1;[delky(:,1),delky(:,2),a1,delky(:,3)]];
    Delky2 = [Delky2;[delky2(:,1),delky2(:,2),a2,delky2(:,3)]];

end

%% Výpočet astronomických azimutů

astro_azimut_1 = readtable('Vysledky_nove.xlsx');

astro_azimut = []; % will become numeric matrix

for i = 1 : 2 : size(astro_azimut_1,1)-1
    az1 = str2double(astro_azimut_1.Azimut(i));
    az2 = str2double(astro_azimut_1.Azimut(i+1));
    avgAz = (az1 + az2) / 2;

    pom = [astro_azimut_1.Stanovisko(i),astro_azimut_1.ID(i),astro_azimut_1.Cil(i),avgAz];
    astro_azimut = [astro_azimut; pom];
end


%% Kompletace dat
observace = {};
for i = 1:pocet_stanovisek
    pom_1 = data_structs{i};
    uhly = pom_1.uhel;
    stanovisko = str2double(pom_1.stanovisko(1:4));

    [a] = check_stanovisko(pom_1);

    centrace = opravy_smeru(opravy_smeru(:,1) == stanovisko & opravy_smeru(:,2) == a, :);
    red_JTSK = redukce_JTSK(redukce_JTSK(:,1) == stanovisko & redukce_JTSK(:,2) == a, :);
    distance = Delky2(Delky2(:,1)==stanovisko & Delky2(:,3) == a, :);
    astro = astro_azimut(astro_azimut(:,1) == stanovisko & astro_azimut(:,2) == a,:);

    angle = cell(size(uhly,1), 4);
    for j = 1:size(uhly,2)
       zaz_1 = uhly(j);
       id_l = str2num(zaz_1.id_leva);
       id_p = str2num(zaz_1.id_prava);

       Oprava = centrace(centrace(:,3)==id_l,4) + centrace(centrace(:,3)==id_p,4) + red_JTSK(red_JTSK(:,3)==id_l,4) + red_JTSK(red_JTSK(:,3)==id_p,4);

       angle{j,1} = 'angle';
       angle{j,2} = id_l;
       angle{j,3} = id_p;
       angle{j,4} = zaz_1.hodnota + Oprava;
    end

    astr = cell(size(astro,1), 3);
    for j = 1:size(astro,1)
        id_cil = astro(j,3);

        Oprava = centrace(centrace(:,3)==id_cil,4) + red_JTSK(red_JTSK(:,3)==id_cil,4);

        astr{j,1} = 'azimuth';
        astr{j,2} = id_cil;
        astr{j,3} = astro(j,4) + Oprava;
    end

    dist = cell(size(distance,1), 3);
    for j = 1:size(dist,1)
        dist{j,1} = 'distance';
        dist{j,2} = distance(j,2);
        dist{j,3} = distance(j,4);
    end

    obsst = {stanovisko,{angle;dist;astr}};

    observace = [observace,{obsst}];
end

stanovisko = str2double(id_azimut);
red_JTSK = redukce_JTSK(redukce_JTSK(:,3) == stanovisko,4)*(-1);
azimut = {gyro_mereni.azimut};
opravy = {gyro_mereni.oprava};

gyro = cell(size(gyro_mereni,2), 3);
for i = 1:size(gyro_mereni,2)
    gyro{i,1} = 'azimuth';
    gyro{i,2} = 1003;
    gyro{i,3} = azimut{i}/180*200 + opravy{i} + red_JTSK;
end
obsst = {stanovisko,{gyro}};
observace = [observace,{obsst}];

%% Vytvoření XML souboru pro vyrovnání v Gamě
% vstupni parametry - upravit dle potreby
% popis
description = {'Volná síť, opěrné 1001,1002', '155VTTG - sk1,3 2025'};
% apriorní směrodatná odchylka
sigma_apr = 1.0;
% interval spolehlivostiMicrosoft.QuickAction.Bluetooth
conf_pr = 0.95;
% tolerance
tol_abs = 1000.0;
% sm. o. vyuzita pro vypocet vyslednych sm.o. (apriori/aposteriori)
sigma_act = 'apriori';
% sm. och. merenych velicin
    %bud obecne zde, nebo muze byt upresneno u konkretniho mereni jako
    %volitelny dalsi parametr
angStdev = "10"; % v gradovych vterinach
distStdev = "5 3 1"; % a + b*D^c, D je v km
azimStdev = "10"; % v gradovych vterinach

% Souřadnice bodů v S-JTSK
% points = {
%     {4001,'fix', 5000, 1000}; % bod je fixní
%     {4002,'adj','XY', 5000, 1000}; % bod je opěrný
%     {4003,'adj','xy', 5000, 1000}; % bod je vyrovnávaný
%     {4004,'adj','xy'}; % bod je vyrovnávaný a nemáme přibliž. souř
% };

points = {
    {1001,'adj','XY', 1055386.291, 565725.159};
    {1002,'adj','XY', 1058509.547, 560713.097};
    {1003,'adj','xy', 1055296.051, 560933.350}; 
    {1004,'adj','xy', 1053013.574, 559765.560}; 
    {1005,'adj','xy', 1055721.093, 562456.195};
};

% Měření: {typ, kam, hodnota}
obs1001 = {1001, {
    {'angle', 422, 402, 128.6548};
    {'distance', 4002, 538.84}
    {'azimuth', 4002, 122.8445};
}};
obs1002 = {1002, {
    {'angle',     4003,4001, 61.1804};
    {'distance',  4001, 538.87};
}};
obsArray = {obs1001, obs1002};

% generovani
generate_gama_xml('gama_xml.xml', description, sigma_apr, conf_pr, tol_abs, sigma_act, points, observace, angStdev, distStdev,azimStdev);


function [a] = check_stanovisko(pom_1)
    if length(pom_1.stanovisko) > 4
        if pom_1.stanovisko(5) == 'a'
            a = 1;
        else
            a = 2;
        end
    else
        a = 0;
    end  
end